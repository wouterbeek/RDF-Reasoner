#+author: Wouter Beek
#+title: RDF-Tabling
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/htmlize.css"/>
#+HTML_HEAD: <link rel="stylesheet" type="text/css" href="https://www.pirilampo.org/styles/readtheorg/css/readtheorg.css"/>
#+HTML_HEAD: <script src="https://ajax.googleapis.com/ajax/libs/jquery/2.1.3/jquery.min.js"></script>
#+HTML_HEAD: <script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.4/js/bootstrap.min.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/lib/js/jquery.stickytableheaders.js"></script>
#+HTML_HEAD: <script type="text/javascript" src="https://www.pirilampo.org/styles/readtheorg/js/readtheorg.js"></script>
#+STARTUP: inlineimages
#+STARTUP: latexpreview

This library implements full RDF(S) entailment using mode-directed
tabling.

Firstly, this library is able to determine whether a given atomic
ground fact is true or not, based on a specified collection of axioms,
recognized datatype IRIs, and rules.  Secondly, it is also able to
enumerate all and only variable bindings that make a given non-ground
fact true.  Finally, the library is able to return a shortest proof
for each solution (where a proof brevity is defines in terms of the
depth of the proof tree).  Proof trees are exported using
DOT/GraphViz.

This library is implemented in SWI-Prolog, and uses SWI's standard
tabling and Semantic Web libraries.  The implementation tries to
strictly adhere to the [[https://www.w3.org/TR/rdf11-mt/][RDF 1.1 Semantics Recommendation (2014-02-25)]].

Please [[https://github.com/wouterbeek/RDF-Tabling/issues][open a Github issue]] if you found a bug, have a suggestion, or
just want to say hi.

* Installation

  1. Install [[http://www.swi-prolog.org][SWI-Prolog]], an awesome logic programming language with
     exquisite Semantic Web support.
  2. Start SWI-Prolog and install this library using the Prolog
     package manager:
     ~pack_install('git://github.com/wouterbeek/rdf_tabling').~
  3. From now on, you can use the library by loading it as follows:
     ~[library(semweb/rdf_tabling)].~
  4. Optionally, in case you want to see visualizations of proof
     trees, install [[http://www.graphviz.org/][GraphViz]]:
     - On Red Hat-based distro's (e.g., Fedora): ~sudo dnf install graphviz~
     - On Debian-based distro's (e.g., Ubuntu): ~sudo apt install graphviz~

* Example use

** Check whether a specific statement can be proven

#+BEGIN_SRC prolog
?- rdf_proof(rdf(rdfs:'Class',rdf:type,rdfs:'Class')).
true.
#+END_SRC

** Obtain a proof tree for a specific statement

It's great that this statement can be proven, but I would like to see
a particular proof:

#+BEGIN_SRC prolog
?- rdf_proof_tree(rdf(rdfs:'Class',rdf:type,rdfs:'Class').
#+END_SRC

This displays the following proof tree:

[[./doc/img/class.svg]]

** Non-empty setup stage

This library distinguishing between the following two stages: setup
and reasoning.  During the setup stage, the set of axioms, recognized
datatype IRIs, rules, and database statements can be arbitrarily
extended.  The setup stage is ended, and the reasoning stage is
entered, when the first proof is invoked.

First, we add the following statements to our database, here expressed
in Turtle:

#+BEGIN_SRC ttl
ex:happyMarriedTo rdfs:subPropertyOf _:1       .
_:1               rdfs:domain        ex:Person .
ex:markus         ex:happyMarriedTo  ex:anja   .
#+END_SRC

At the Prolog top-level, this is done in the following way:

#+BEGIN_SRC prolog
?- add_statement(rdf(ex:happyMarriedTo,rdfs:subPropertyOf,'_:1')).
?- add_statement(rdf('_:1',rdfs:domain,ex:'Person')).
?- add_statement(rdf(ex:markus,ex:happyMarriedTo,ex:anja)).
#+END_SRC

Now that we have extended our database, we want to prove the following
statement expressed in Turtle:

#+BEGIN_SRC ttl
ex:markus a ex:Person .
#+END_SRC

At the Prolog top-level, this is done as follows:

#+BEGIN_SRC prolog
?- rdf_proof_tree(rdf(ex:markus,rdf:type,ex:'Person')).
#+END_SRC

[[./doc/img/markus.svg]]

Notice that this is an example of a proof tree that cannot be
expressed in terms of regular triples, and requires generalized
triples.

** Non-ground conclusions

The above examples have all tried to prove a conclusion that is
ground.  In addition, it is also possible to prove non-ground
statements.  The fact that the conclusion is non-ground is indicated
by the Prolog variables ~P~ and ~O~.  A solution is a binding for
these two variables that results in a provable ground statement.

#+BEGIN_SRC prolog
?- add_statement(rdf(rdf:s,rdf:p,""^^xsd:string)).
?- rdf_proof_tree(rdf(""^^xsd:string,P,O)).
P = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
O = 'http://www.w3.org/2000/01/rdf-schema#Resource' ;
#+END_SRC

The bindings for ~P~ and ~O~ that are printed at the top-level result
in a provable ground statement.  In addition, the following proof tree
is shown:

[[./doc/img/string-1.svg]]

In this case, there are multiple solutions, i.e., multiple bindings
for the variables ~P~ and ~O~ that result in a ground statement that
can be proven.

Such additional solutions can be requested at the Prolog top-level by
pressing the semicolon key (~;~):

#+BEGIN_SRC prolog
P = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
O = 'http://www.w3.org/2001/XMLSchema#string' ;
#+END_SRC

[[./doc/img/string-2.svg]]

And by pressing the semicolon a second time, we get the third
solution:

#+BEGIN_SRC prolog
P = 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type',
O = 'http://www.w3.org/2000/01/rdf-schema#Literal'.
#+END_SRC

[[./doc/img/string-3.svg]]

There are no more solutions, and it is not possible to press the
semicolon a third time.  At the top level, this is indicated by the
dot (~.~) character.
